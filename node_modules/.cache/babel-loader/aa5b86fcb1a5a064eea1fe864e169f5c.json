{"ast":null,"code":"var http = require('http'),\n    https = require('https'),\n    common = require('../common');\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n  checkMethodAndHeader: function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  XHeaders: function XHeaders(req, socket, options) {\n    if (!options.xfwd) return;\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream: function stream(req, socket, options, head, server, clb) {\n    var createHttpHeader = function (line, headers) {\n      return Object.keys(headers).reduce(function (head, key) {\n        var value = headers[key];\n\n        if (!Array.isArray(value)) {\n          head.push(key + ': ' + value);\n          return head;\n        }\n\n        for (var i = 0; i < value.length; i++) {\n          head.push(key + ': ' + value[i]);\n        }\n\n        return head;\n      }, [line]).join('\\r\\n') + '\\r\\n\\r\\n';\n    };\n\n    common.setupSocket(socket);\n    if (head && head.length) socket.unshift(head);\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req)); // Enable developers to modify the proxyReq before headers are sent\n\n    if (server) {\n      server.emit('proxyReqWs', proxyReq, req, socket, options, head);\n    } // Error Handler\n\n\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) {\n        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));\n        res.pipe(socket);\n      }\n    });\n    proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError); // Allow us to listen when the websocket has completed\n\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      }); // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n      common.setupSocket(proxySocket);\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead); //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n\n      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));\n      proxySocket.pipe(socket).pipe(proxySocket);\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket); //DEPRECATED.\n    });\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n\n      socket.end();\n    }\n  }\n};","map":{"version":3,"sources":["/home/shubhangi/Documents/mentor-and-mentee-tracking-/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js"],"names":["http","require","https","common","module","exports","checkMethodAndHeader","req","socket","method","headers","upgrade","destroy","toLowerCase","XHeaders","options","xfwd","values","for","connection","remoteAddress","port","getPort","proto","hasEncryptedConnection","forEach","header","stream","head","server","clb","createHttpHeader","line","Object","keys","reduce","key","value","Array","isArray","push","i","length","join","setupSocket","unshift","proxyReq","isSSL","test","target","protocol","request","setupOutgoing","ssl","emit","on","onOutgoingError","res","write","httpVersion","statusCode","statusMessage","pipe","proxyRes","proxySocket","proxyHead","end","err"],"mappings":"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","sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    common = require('../common');\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  checkMethodAndHeader : function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders : function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream : function stream(req, socket, options, head, server, clb) {\n\n    var createHttpHeader = function(line, headers) {\n      return Object.keys(headers).reduce(function (head, key) {\n        var value = headers[key];\n\n        if (!Array.isArray(value)) {\n          head.push(key + ': ' + value);\n          return head;\n        }\n\n        for (var i = 0; i < value.length; i++) {\n          head.push(key + ': ' + value[i]);\n        }\n        return head;\n      }, [line])\n      .join('\\r\\n') + '\\r\\n\\r\\n';\n    }\n\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }\n\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) {\n        socket.write(createHttpHeader('HTTP/' + res.httpVersion + ' ' + res.statusCode + ' ' + res.statusMessage, res.headers));\n        res.pipe(socket);\n      }\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(createHttpHeader('HTTP/1.1 101 Switching Protocols', proxyRes.headers));\n\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}