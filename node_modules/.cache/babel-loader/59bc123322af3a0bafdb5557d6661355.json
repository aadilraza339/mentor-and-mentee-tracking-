{"ast":null,"code":"var url = require('url'),\n    common = require('../common');\n\nvar redirectRegex = /^201|30(1|2|7|8)$/;\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\nmodule.exports = {\n  // <--\n\n  /**\n   * If is a HTTP 1.0 request, remove chunk headers\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  removeChunked: function removeChunked(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      delete proxyRes.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * If is a HTTP 1.0 request, set the correct connection header\n   * or if connection header not present, then use `keep-alive`\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  setConnection: function setConnection(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      proxyRes.headers.connection = req.headers.connection || 'close';\n    } else if (req.httpVersion !== '2.0' && !proxyRes.headers.connection) {\n      proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n    }\n  },\n  setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {\n    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite) && proxyRes.headers['location'] && redirectRegex.test(proxyRes.statusCode)) {\n      var target = url.parse(options.target);\n      var u = url.parse(proxyRes.headers['location']); // make sure the redirected host matches the target host before rewriting\n\n      if (target.host != u.host) {\n        return;\n      }\n\n      if (options.hostRewrite) {\n        u.host = options.hostRewrite;\n      } else if (options.autoRewrite) {\n        u.host = req.headers['host'];\n      }\n\n      if (options.protocolRewrite) {\n        u.protocol = options.protocolRewrite;\n      }\n\n      proxyRes.headers['location'] = u.format();\n    }\n  },\n\n  /**\n   * Copy headers from proxyResponse to response\n   * set each header in response object.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain\n   *\n   * @api private\n   */\n  writeHeaders: function writeHeaders(req, res, proxyRes, options) {\n    var rewriteCookieDomainConfig = options.cookieDomainRewrite,\n        rewriteCookiePathConfig = options.cookiePathRewrite,\n        preserveHeaderKeyCase = options.preserveHeaderKeyCase,\n        rawHeaderKeyMap,\n        setHeader = function (key, header) {\n      if (header == undefined) return;\n\n      if (rewriteCookieDomainConfig && key.toLowerCase() === 'set-cookie') {\n        header = common.rewriteCookieProperty(header, rewriteCookieDomainConfig, 'domain');\n      }\n\n      if (rewriteCookiePathConfig && key.toLowerCase() === 'set-cookie') {\n        header = common.rewriteCookieProperty(header, rewriteCookiePathConfig, 'path');\n      }\n\n      res.setHeader(String(key).trim(), header);\n    };\n\n    if (typeof rewriteCookieDomainConfig === 'string') {\n      //also test for ''\n      rewriteCookieDomainConfig = {\n        '*': rewriteCookieDomainConfig\n      };\n    }\n\n    if (typeof rewriteCookiePathConfig === 'string') {\n      //also test for ''\n      rewriteCookiePathConfig = {\n        '*': rewriteCookiePathConfig\n      };\n    } // message.rawHeaders is added in: v0.11.6\n    // https://nodejs.org/api/http.html#http_message_rawheaders\n\n\n    if (preserveHeaderKeyCase && proxyRes.rawHeaders != undefined) {\n      rawHeaderKeyMap = {};\n\n      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {\n        var key = proxyRes.rawHeaders[i];\n        rawHeaderKeyMap[key.toLowerCase()] = key;\n      }\n    }\n\n    Object.keys(proxyRes.headers).forEach(function (key) {\n      var header = proxyRes.headers[key];\n\n      if (preserveHeaderKeyCase && rawHeaderKeyMap) {\n        key = rawHeaderKeyMap[key] || key;\n      }\n\n      setHeader(key, header);\n    });\n  },\n\n  /**\n   * Set the statusCode from the proxyResponse\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  writeStatusCode: function writeStatusCode(req, res, proxyRes) {\n    // From Node.js docs: response.writeHead(statusCode[, statusMessage][, headers])\n    if (proxyRes.statusMessage) {\n      res.statusCode = proxyRes.statusCode;\n      res.statusMessage = proxyRes.statusMessage;\n    } else {\n      res.statusCode = proxyRes.statusCode;\n    }\n  }\n};","map":{"version":3,"sources":["/home/shubhangi/Documents/mentor-and-mentee-tracking-/node_modules/http-proxy/lib/http-proxy/passes/web-outgoing.js"],"names":["url","require","common","redirectRegex","module","exports","removeChunked","req","res","proxyRes","httpVersion","headers","setConnection","connection","setRedirectHostRewrite","options","hostRewrite","autoRewrite","protocolRewrite","test","statusCode","target","parse","u","host","protocol","format","writeHeaders","rewriteCookieDomainConfig","cookieDomainRewrite","rewriteCookiePathConfig","cookiePathRewrite","preserveHeaderKeyCase","rawHeaderKeyMap","setHeader","key","header","undefined","toLowerCase","rewriteCookieProperty","String","trim","rawHeaders","i","length","Object","keys","forEach","writeStatusCode","statusMessage"],"mappings":"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","sourcesContent":["var url    = require('url'),\n    common = require('../common');\n\n\nvar redirectRegex = /^201|30(1|2|7|8)$/;\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, res, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\nmodule.exports = { // <--\n\n  /**\n   * If is a HTTP 1.0 request, remove chunk headers\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  removeChunked: function removeChunked(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      delete proxyRes.headers['transfer-encoding'];\n    }\n  },\n\n  /**\n   * If is a HTTP 1.0 request, set the correct connection header\n   * or if connection header not present, then use `keep-alive`\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  setConnection: function setConnection(req, res, proxyRes) {\n    if (req.httpVersion === '1.0') {\n      proxyRes.headers.connection = req.headers.connection || 'close';\n    } else if (req.httpVersion !== '2.0' && !proxyRes.headers.connection) {\n      proxyRes.headers.connection = req.headers.connection || 'keep-alive';\n    }\n  },\n\n  setRedirectHostRewrite: function setRedirectHostRewrite(req, res, proxyRes, options) {\n    if ((options.hostRewrite || options.autoRewrite || options.protocolRewrite)\n        && proxyRes.headers['location']\n        && redirectRegex.test(proxyRes.statusCode)) {\n      var target = url.parse(options.target);\n      var u = url.parse(proxyRes.headers['location']);\n\n      // make sure the redirected host matches the target host before rewriting\n      if (target.host != u.host) {\n        return;\n      }\n\n      if (options.hostRewrite) {\n        u.host = options.hostRewrite;\n      } else if (options.autoRewrite) {\n        u.host = req.headers['host'];\n      }\n      if (options.protocolRewrite) {\n        u.protocol = options.protocolRewrite;\n      }\n\n      proxyRes.headers['location'] = u.format();\n    }\n  },\n  /**\n   * Copy headers from proxyResponse to response\n   * set each header in response object.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain\n   *\n   * @api private\n   */\n  writeHeaders: function writeHeaders(req, res, proxyRes, options) {\n    var rewriteCookieDomainConfig = options.cookieDomainRewrite,\n        rewriteCookiePathConfig = options.cookiePathRewrite,\n        preserveHeaderKeyCase = options.preserveHeaderKeyCase,\n        rawHeaderKeyMap,\n        setHeader = function(key, header) {\n          if (header == undefined) return;\n          if (rewriteCookieDomainConfig && key.toLowerCase() === 'set-cookie') {\n            header = common.rewriteCookieProperty(header, rewriteCookieDomainConfig, 'domain');\n          }\n          if (rewriteCookiePathConfig && key.toLowerCase() === 'set-cookie') {\n            header = common.rewriteCookieProperty(header, rewriteCookiePathConfig, 'path');\n          }\n          res.setHeader(String(key).trim(), header);\n        };\n\n    if (typeof rewriteCookieDomainConfig === 'string') { //also test for ''\n      rewriteCookieDomainConfig = { '*': rewriteCookieDomainConfig };\n    }\n\n    if (typeof rewriteCookiePathConfig === 'string') { //also test for ''\n      rewriteCookiePathConfig = { '*': rewriteCookiePathConfig };\n    }\n\n    // message.rawHeaders is added in: v0.11.6\n    // https://nodejs.org/api/http.html#http_message_rawheaders\n    if (preserveHeaderKeyCase && proxyRes.rawHeaders != undefined) {\n      rawHeaderKeyMap = {};\n      for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {\n        var key = proxyRes.rawHeaders[i];\n        rawHeaderKeyMap[key.toLowerCase()] = key;\n      }\n    }\n\n    Object.keys(proxyRes.headers).forEach(function(key) {\n      var header = proxyRes.headers[key];\n      if (preserveHeaderKeyCase && rawHeaderKeyMap) {\n        key = rawHeaderKeyMap[key] || key;\n      }\n      setHeader(key, header);\n    });\n  },\n\n  /**\n   * Set the statusCode from the proxyResponse\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {IncomingMessage} Res Response object\n   * @param {proxyResponse} Res Response object from the proxy request\n   *\n   * @api private\n   */\n  writeStatusCode: function writeStatusCode(req, res, proxyRes) {\n    // From Node.js docs: response.writeHead(statusCode[, statusMessage][, headers])\n    if(proxyRes.statusMessage) {\n      res.statusCode = proxyRes.statusCode;\n      res.statusMessage = proxyRes.statusMessage;\n    } else {\n      res.statusCode = proxyRes.statusCode;\n    }\n  }\n\n};\n"]},"metadata":{},"sourceType":"script"}